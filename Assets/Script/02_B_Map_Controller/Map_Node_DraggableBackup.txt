using UnityEngine.UIElements;
using UnityEngine;

namespace ATC.Operator.MapView {
    
    public struct Map_Node_Draggable {
        [Header("Root Element")]
        private VisualElement _parentContainer;

        // The specific VisualElement that will be draggable
        internal VisualElement draggableRoot;
        private Vector3 _tmp_Mouse_Pos;
        private Vector3 _tmp_Draggable_Initial_Pos;
        // private Vector2 draggableOffset;
        // --- MODIFIED: Private backing field for the property ---
        private bool _isDraggingBackingField;
        // --- MODIFIED: Public property with get/set for logging ---
        private bool _isActuallyDragging {
            get { return _isDraggingBackingField; }
            set {
                if (_isDraggingBackingField != value) // Only log if the value actually changes
                {
                    Debug.Log($"[IsDragging SET] From {_isDraggingBackingField} to {value} at {Time.frameCount}");
                    _isDraggingBackingField = value;
                }
            }
        }


        private const float margin = 20f;

        private float minX;
        private float maxX;
        private float minY;
        private float maxY;
        private Vector2 draggablePosition;
        private Vector2 lastApCenterPos;

        internal void Initialize(VisualElement mapNodeRoot, VisualElement parentContainer) {
            // find root and parent
            _parentContainer = parentContainer;
            draggableRoot = mapNodeRoot.Q<VisualElement>("draggableRoot");

            // Register event callbacks for drag functionality
            draggableRoot.RegisterCallback<PointerDownEvent>(OnPointerDown);
            draggableRoot.RegisterCallback<PointerMoveEvent>(OnPointerMove);
            draggableRoot.RegisterCallback<PointerUpEvent>(OnPointerUp);

            // Calculate bound
            CalculateMinMaxBound();
        }

        private void CalculateMinMaxBound() {
            // Get the parent container's dimensions
            Rect parentRect = _parentContainer.layout;
            float parentWidth = parentRect.width;
            float parentHeight = parentRect.height;

            // Get the draggable element's current dimensions
            float elementWidth = draggableRoot.layout.width;
            float elementHeight = draggableRoot.layout.height;

            // Calculate the min/max allowed positions for the element's top-left corner
            // ensuring the entire element stays within the parent with the defined margin.
            minX = margin;
            maxX = parentWidth - elementWidth - margin;

            minY = margin;
            maxY = parentHeight - elementHeight - margin;
        }

        private void OnPointerDown(PointerDownEvent evt) {
            /* // Only initiate drag with the left mouse button
             if (evt.button == (int)MouseButton.LeftMouse) {
                 _isActuallyDragging = true;
                 // Capture pointer to receive move events even if cursor leaves the element
                 draggableRoot.CapturePointer(evt.pointerId);
                 // record mouse positoin
                 _tmp_Mouse_Pos = evt.position;

                 //CalculateMinMaxBound();
                 // Store the element's position relative to its parent at the start of the drag
                 _tmp_Draggable_Initial_Pos = new Vector2(draggableRoot.layout.x, draggableRoot.layout.y);
             }
             // Stop event propagation to prevent it from bubbling up to parent elements
             evt.StopPropagation();*/
            _isActuallyDragging = true;
            Debug.Log("PD_END" + _isActuallyDragging);
        }

        private void OnPointerMove(PointerMoveEvent evt) {
         /*   // Proceed only if dragging is active and the element has pointer capture
            if (_isDragging && draggableRoot.HasPointerCapture(evt.pointerId)) {
                // Calculate how much the mouse has moved since the drag started
                Vector2 mouseDelta = evt.position - _tmp_Mouse_Pos;
                
                // set and clamp position based on mouse delta
                SetClampPosition(_tmp_Draggable_Initial_Pos.x + mouseDelta.x, _tmp_Draggable_Initial_Pos.y + mouseDelta.y);
            }
            evt.StopPropagation();*/
        }

        private void OnPointerUp(PointerUpEvent evt) {
            Debug.Log("UP_SS" + _isActuallyDragging);
          /*  // Release drag state and pointer capture if active
            if (_isDragging && draggableRoot.HasPointerCapture(evt.pointerId)) {
                _isDragging = false;
                draggableRoot.ReleasePointer(evt.pointerId);
               // RecordDraggableOffset();
            }
            evt.StopPropagation();
            Debug.Log("UP_End" + this._isDragging);*/
        }
        private void RecordDraggableOffset() {
           // draggableOffset.x = draggableRoot.layout.x - lastApCenterPos.x;
           // draggableOffset.y = draggableRoot.layout.y - lastApCenterPos.y;
        }
        private void SetClampPosition(float xPos, float yPos) {
            draggableRoot.style.left = xPos;// Mathf.Clamp(xPos, minX, maxX);
            draggableRoot.style.top = yPos; // Mathf.Clamp(yPos, minY, maxY);
        }



        internal void ChangePositionByAirplane(Vector2 _airplaneCenterPosition) {
            lastApCenterPos = _airplaneCenterPosition;
          /*  if (!_isDragging) {
              //  SetClampPosition(lastApCenterPos.x + draggableOffset.x, lastApCenterPos.y + draggableOffset.y);
            }*/
        }


    }
}